Primeira situação: Histórico vazio -- 50-50
	Sacar as 10 séries mais populares; Random para 6 séries e das outras 4 ir sacar actor random

Ultimas pessoas e séries vistas:
	Dividir em ultimas pessoas + ultimas series; Sacar as séries das pessoas, meter num array

	Sacar séries em comum das pessoas - Se houverem séries em comum que ainda nao foram vistas incluir nas séries recomendadas (max 3) -- Se sobrarem encher os outros

	Pegar no array de séries das pessoas, ordenar por score e procurar a série com maior score ainda nao vista (max 2)

	Pegar nas séries vistas e sacar actores em comum que ainda nao tenham sido vistos (max 3)

	Pegar nas series vistas e sacar os generos em comum e sacar series com maior score desses generos mais frequentes, séries do mais frequente, etc (max 2)

	Caso sem histórico


PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX my: <http://www.semanticweb.org/tv/series/ontologies/Tv-Series-Ontology#>
SELECT ?subject ?seriesName ?actor ?creator
WHERE { 
       ?subject my:hasSeriesId ?id FILTER( regex(?id, 'tt1219024') ) .
       ?subject my:hasTitle ?seriesName .
      {?subject my:hasActor ?actor} UNION {?subject my:hasCreator ?creator} .
} USE RANDOM OFFSET BASED ON NUMBER OF ACTORS (Determined in jena). LIMIT IS ALWAYS 1