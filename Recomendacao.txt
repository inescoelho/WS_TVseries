Primeira situação: Histórico vazio -- 50-50
	Sacar as 10 séries mais populares; Random para 6 séries e das outras 4 ir sacar actor random

Ultimas pessoas e séries vistas:
	Dividir em ultimas pessoas + ultimas series; Sacar as séries das pessoas, meter num array -- DONE

	Sacar séries em comum das pessoas - Se houverem séries em comum que ainda nao foram vistas incluir nas séries recomendadas (max 3) -- Se sobrarem encher os outros (Acho que vou cagar nisto de encher os outros) -- DONE

	Pegar no array de séries das pessoas, ordenar por score e procurar a série com maior score ainda nao vista (max 2) -- DONE

	Pegar nas séries vistas e sacar actores em comum que ainda nao tenham sido vistos (max 3) -- Vou fazer algo parecido com o que fizémos no passo anterior para as séries: Vou sacar os actores das séries vistas e contar a frequência deles. Depois ordeno isso por frequência. Se houverem actores com frequência superior a 1 então tiro 2 random dai e o outro e random de entre os que tem score 1. Caso contrário, se só houverem actores com frequencia 1, então e sacar 3 random e pronto -- DONE

	Pegar nas series vistas e sacar os generos em comum e sacar series com maior score desses generos mais frequentes, séries do mais frequente, etc (max 2)

	Caso sem histórico -- DONE


PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX my: <http://www.semanticweb.org/tv/series/ontologies/Tv-Series-Ontology#>
SELECT ?subject ?seriesName ?actor ?creator
WHERE {
		{
			?subject my:hasSeriesId ?id FILTER( regex(?id, 'tt1219024') ) .
			?subject my:hasTitle ?seriesName .
			{ ?subject my:hasActor ?actor} UNION {?subject my:hasCreator ?creator} .
		}
		UNION
		{
			?subject my:hasSeriesId ?id FILTER( regex(?id, 'tt375355') ) .
			?subject my:hasTitle ?seriesName .
			{ ?subject my:hasActor ?actor} UNION {?subject my:hasCreator ?creator} .
		}
		UNION
		{
			?subject my:hasSeriesId ?id FILTER( regex(?id, 'tt375355') ) .
			?subject my:hasTitle ?seriesName .
			{ ?subject my:hasActor ?actor} UNION {?subject my:hasCreator ?creator} .
		}
		UNION
		{
			?subject my:hasSeriesId ?id FILTER( regex(?id, 'tt182576') ) .
			?subject my:hasTitle ?seriesName .
			{ ?subject my:hasActor ?actor} UNION {?subject my:hasCreator ?creator} .
		}
} OFFSET 20 LIMIT 1

USE RANDOM OFFSET BASED ON NUMBER OF ACTORS (Determined in jena). LIMIT IS ALWAYS 